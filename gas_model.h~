// classes defines the gas model
#include <stdio.h>
#include <math.h>
#include <iostream>
#include <vector>
#include <algorithm>
#include <gsl/gsl_integration.h>
#include <gsl/gsl_sf.h>
#include <gsl/gsl_vector.h>
#include <gsl/gsl_multimin.h>
#include <gsl/gsl_dht.h>
#include <gsl/gsl_interp.h>
#include <gsl/gsl_spline.h>
double sx_func (double x, void * params);
double ss_func (double x, void * params);
double fx_func (double x, void * params);
double ftx_func (double x, void * params);
double tx_func (double x, void * params);
double tx_func_p (double x, void * params);
double ttx_func (double x, void * params);
double gasmod_apply_bc(const gsl_vector * x, void *p);
double yproj_func(double x, void * params);
double yint_func(double x, void * p);
double arnaud_func(double x, void * p);
double proj_arnaud_func(double x, void * p);
double yfft_func(double x, void * p);
double mgas500_func(double x, void * p);
double arnaud_func_k(double x, void * p);
double yfft_func_k(double x, void * p);
double proj_KS02_func(double x, void * p);
double gasproj_func(double x, void * p);

using namespace std;

struct my_func_params { float a; float b; float c; double d; int e;float f;};

class gas_model {

  friend double sx_func (double x, void * params);
  friend double ss_func (double x, void * params);
  friend double fx_func (double x, void * params);
  friend double ftx_func (double x, void * params);
  friend double tx_func (double x, void * params);
  friend double tx_func_p (double x, void * params);
  friend double ttx_func (double x, void * params);
  friend double gasmod_apply_bc(const gsl_vector * x, void *p);
  friend double yproj_func(double x, void * params);
  friend double yint_func(double x, void * p);
  friend double yfft_func(double x, void * p);
  friend double arnaud_func(double x, void * p);
  friend double proj_arnaud_func(double x, void * p);
  friend double mgas500_func(double x, void * p);
  friend double yfft_func_k(double x, void * p);
  friend double gasproj_func(double x, void * p);
 protected:
  float delta_rel, delta_rel_n, n, eps, eps_dm, fs_0, fs_alpha, f_s, Mpiv, chi_turb, delta_rel_zslope;
  int pturbrad;
  float C, ri, rhoi, mass, radius, vcmax, mgas, Ytot, pressurebound, R500toRvir;
  double xs;
  double final_beta, final_Cf, p0, rho0, T0; // need to define these
  double PI, m_sun, G, mpc, mu_e, mmw, m_p, clight, eV, sigma_T, me_csq, m_e, q, k_B;
  double Aprime, Bprime;
  float *x, *k, Tau_d, Tau_b, bulge_frac;
  double *ysz, *fft_ysz, *ell;
  double *rhogas, *rr, *Tsz, *Ksz;
  int nrads, nell;

 public:

  gas_model(float inp1, float inp2, float inp3, double Ap, double Bp, float inp5, int inp4, float  inp9) {
    Mpiv = 3.0e14; //in Msol
    set_constants();
    delta_rel = inp1;
    n = inp2;
    C = inp3;
    pturbrad = inp4;
    if (pturbrad==1) chi_turb = (n-1.0)/(-1.0*(n+1.0));
    else chi_turb = 0.0;
    Aprime = Ap;
    Bprime = Bp;
    f_s = inp5;
    delta_rel_n = inp9; //0.8;
    pressurebound = 1.0;
  }

  gas_model(float inp1, float inp2, float inp3, float inp4, float inp5, float inp6, int inp7, float inp8, float inp9) {
    delta_rel = inp1;
    delta_rel_zslope = inp8;
    n = inp2;
    eps = inp3;
    eps_dm = inp4;
    fs_0 = inp5;
    fs_alpha = inp6;
    pturbrad = inp7;
    Mpiv = 3.0e14; // in Msol
    if (pturbrad==1) chi_turb = (n-1.0)/(-1.0*(n+1.0));
    else chi_turb = 0.0;
    set_constants();
    // stellar evolution parameters (c.f. Nagamine et al. (2006)
    pressurebound = 1.0;
    delta_rel_n = inp9;//0.8;
    bulge_frac = 0.9;
    Tau_d = 4.5;//4.5; // in Gyr
    Tau_b = 1.5;//1.5; // in Gyr
  }

  void set_constants() {
    PI = 4.*atan(1.);
    m_sun = 1.98892e30; //kg
    clight = 3.0e5; // in km/s
    mpc = 3.0857e22; // in m
    G = 6.67e-11*m_sun/pow(mpc,3); // in mpc^3/Msun/s^2
    //mu_e = 1.143;
    mu_e = 1.136; // X=0.76 assumed
    //mmw = 0.59; // mean molecular weight (see Feng and Nagai 09)
    mmw = 0.58824; // X=0.76 assumed
    m_p  = 1.6726e-27;// mass proton, kg
    eV = 1.602e-19; // 1eV in J
    sigma_T = 6.652e-25/(1.0e4); // now in m^2.
    m_e = 9.11e-31; // mass electron, kg
    q = 1.60217646e-19;// joules
    me_csq = m_e*clight*clight*1.0e6/(1000.0*q); // in KeV
    k_B = 1.380658e-16;
  }

 void evolve_pturb_norm(float z, float outer_radius) {
    float fmax, evo_power, evo_converge;
    if (delta_rel == 0.0) {
      delta_rel = 0.0;
    }
    else if (delta_rel_zslope<=0.0) {
      delta_rel *= pow(1.0 + z, delta_rel_zslope);
    }
    else {
      // This is the old power-law evolution
      evo_power = pow(1.0 + z, delta_rel_zslope);
      // This is the new version that asymptotes to a maximum value, preventing thermal pressure from going negative
      fmax = 1.0 / (delta_rel * pow(outer_radius*2.0, delta_rel_n)); // factor of two converts rvir-> r500
      evo_converge = (fmax - 1.0)*tanh(delta_rel_zslope*z) + 1.0;
      delta_rel *= min(evo_power, evo_converge);
    }
    //cout << "delta_rel at z = " << delta_rel << endl;
  }


  void set_nfw_params(float bmass, float bradius, float conc, float brhoi, float r500) {
    mass = bmass;
    radius = bradius;
    C = conc;
    rhoi = brhoi;
    ri = radius/C;
    //cout<< mass<<" "<<ri<<endl;
    ri = ri*mpc/1000.0; //in km (for later units)
    vcmax = sqrt(4.0*PI*G*rhoi*ri*ri*Gmax()); //% in km/s
    //findxs();// now can calculation radius within which stellar mass is contained
    R500toRvir= r500/radius;
  }

  void set_mgas_init(float baryon_frac_univ) {
    mgas = (baryon_frac_univ)*mass/(1.0+f_s);
  }

  void set_fs(float bfs) {
    f_s = bfs;
  }

  float get_fs() {
    return f_s;
  }

  void set_Mpiv(float bMpiv) {
    Mpiv = bMpiv;
  }


 float calc_fs(float M500, float baryon_frac_univ, float cosm_t0, float cosm_tz) {
    // note M500 must be in Msol
    f_s = min(fs_0 * pow(M500/Mpiv,-1.0*fs_alpha), 0.8*baryon_frac_univ);
    f_s = f_s / (baryon_frac_univ - f_s);
    //cout << "f_s(z=0) " << f_s << " fstarz = " << calc_fstarz(cosm_t0, cosm_tz) << endl;
    f_s = f_s*calc_fstarz(cosm_t0, cosm_tz);
  }

  void set_stellar_evo_params(float inp1, float inp2, float inp3) {
    // reset stellar evolution parameters as in Nagamine et al. 2006
    Tau_b = inp1;
    Tau_d = inp2;
    bulge_frac = inp3;
  }

  float calc_fstarz(float cosm_t0, float cosm_tz) {
    // calculates fraction of stars formed at z = 0 that have formed by redshift z
    // Assumes Nagamine et al 06 evolution of disk and bulge populations by default
    // Use the Nagamine values for Tau_d, Tau_b and bulge_frac;
    float chi_b, chi_d, fb, fd, fstarz;

    chi_b = (1.0 - (cosm_t0/Tau_b + 1.0)*exp(-1.0*cosm_t0/Tau_b));
    chi_d = (1.0 - (cosm_t0/Tau_d + 1.0)*exp(-1.0*cosm_t0/Tau_d));
    fb = bulge_frac/chi_b*(1.0 - (cosm_tz/Tau_b + 1.0)*exp(-1.0*cosm_tz/Tau_b));
    fd = (1.0-bulge_frac)/chi_d*(1.0 - (cosm_tz/Tau_d + 1.0)*exp(-1.0*cosm_tz/Tau_d));
    fstarz = fb + fd;
    //cout<<cosm_t0<<" "<<cosm_tz<<" "<<chi_b<<" "<<chi_d<<" "<<fb<<" "<<fd<<endl;
    return fstarz;
  }

  // now put solvep0rho0 functions in here

  double H(double x) { // eqn 6b
    return  (1/((1+x)*g(x)))*(-1*log(1+x) + (x*(1+x/2))/(1+x));
  }

  double g(double x) { // eqn 2b
    return log(1.0+x) - x/(1.0+x);
  }

  double findxs() { // solve for x_s (sec 3.1)
    // start here!
    vector<float> x(2000), gg(2000);
    int i;
    float mingg;
    for (i=0;i<2000;i++) {
      x[i] = 0.0 + float(i)*(2.0*C/2000.0);
      gg[i] = fabs(g(x[i]) - g(C)*f_s/(1+f_s));
     }
    mingg =  *min_element(gg.begin(), gg.end());
    i = 0;
    if (mingg>2e-3) cout << "Convergence xs error " << mingg << endl;
    while (gg[i]!=mingg) {i++;}
    xs = x[i];
    return xs;
  }

  double f(double x) { // eqn 5
    if (x<=C) return log(1+x)/x - (1/(1+C));
    else if (x>C) return (C/x)*((log(1+C)/C) - (1/(1+C)));
  }


  double Gmax() { // eqn 3b
    float xmax = 2.163; // check this number!
    return g(xmax)/xmax;
  }

  double delta_s() { // eqn 15
    return S_C(C) / (S_C(C) + H(C)*g(C)/pow(C,3.0));
  }

  double S_C(double x) { // eqn 11
    double SC;
    SC = pow(PI,2)/2.0 - log(x)/2.0 - 1.0/(2.0*x) - 1.0/(2.0*pow(1.0+x,2)) - 3.0/(1+x);
    SC = SC + (0.5 + 1.0/(2.0*pow(x,2)) - 2.0/x - 1.0/(1.0+x))*log(1.0+x);
    SC = SC + (3.0/2.0)*log(1.0+x)*log(1.0+x);
    SC = SC + 3.0*gsl_sf_dilog(-1.0*x); // gsl dilog function
    //SC = SC*g(x)*g(x);// this is the correction made to Ostriker et al 05.
    // (Mar 10) Don't think it should be here.
    return (double)SC;
  }

  void test_dilog() {
    cout << gsl_sf_dilog(-3.0) << endl;
  }

  double S_cx(double x) { // % eqn 7b
    gsl_integration_workspace * w = gsl_integration_workspace_alloc (2000);
    double result, error, Sx, alpha = 0.0;
    gsl_function F;
    F.function = &sx_func;
    if (x==0) x = 1e-7; //% diverges at x = 0
    gsl_integration_qags (&F, x, C, 0, 1e-7, 2000, w, &result, &error);
    Sx = S_C(C) - result;
    gsl_integration_workspace_free (w);
    return (double)Sx;
  }

  double K(double x) { //% eqn 16
    double Kx = (1.0/3.0)*H(x)*(1./(Gmax()*(1.0-delta_s())));
    return Kx;
  }


  double K_s() { // % eqn 21
    gsl_integration_workspace * w = gsl_integration_workspace_alloc (10000);
    double resulta, resultb, error, Ks, tempC = C;
    gsl_function F,FF;
    F.function = &ss_func;
    FF.function = &fx_func;
    F.params = &tempC;
    FF.params = &tempC;
    gsl_integration_qags (&F, 0.0e-4, xs, 0, 1e-7, 10000, w, &resulta, &error);
    gsl_integration_qags (&FF, 0.0e-4, xs, 0, 1e-7, 10000, w, &resultb, &error);
    Ks = (1.0/g(C))*(resulta - (2.0/3.0)*resultb);
    gsl_integration_workspace_free (w);
    return Ks;
  }

  double theta(double x, double beta) { // % eqn 26b
    double th;
    if (pturbrad==1) {
      th = (-1.0*beta*j(x)/(n+1.0) + 1.0 + chi_turb*delta_rel)/2.0;
      th = th + 0.5*sqrt(pow(1.0 + chi_turb*delta_rel - beta*j(x)/(n+1.0),2) - 4.0*chi_turb*delta_rel);
    }
    else if (pturbrad==2) th =  (double)(1.0 - (beta*j(x)/(1.0+n)));
    else th =  (double)(1.0 - (beta*j(x)/((1.0+n)*(1.0+delta_rel))));
    return (double)fabs(th);
  }


  double  j(double x) { //% eqn 25b
    double jj;
    if (x==0.0) jj = 0.0;
    else if (x<=C) jj = 1.0 - log(1.0+x)/x;
    else jj = 1.0 - 1.0/(1.0+C) - (log(1.0+C) - C/(1.0+C))/x;
    return jj;
  }

  double I2(double Cf, double beta) {// % eqn 28a
    gsl_integration_workspace * w = gsl_integration_workspace_alloc (10000);
    double result, error;
    struct my_func_params params = { delta_rel, n, C, beta, pturbrad };
    gsl_function F;
    F.function = &ftx_func;
    F.params = &params;
    gsl_integration_qags (&F, 0.0, Cf, 0, 1e-5, 10000, w, &result, &error);
    gsl_integration_workspace_free (w);
    return result;
  }

  double I2spline(double Cf, double beta) {// % eqn 27 {
    int nxbins = 1000, i;
    gsl_interp_accel *acc = gsl_interp_accel_alloc ();
    gsl_spline *spline = gsl_spline_alloc (gsl_interp_cspline, nxbins);
    double *xx, *ftx, result;
    xx = new double [nxbins];
    ftx = new double [nxbins];
    // first need to make an array of values
    if (Cf<0) cout << "Cf error! " << Cf << endl;
    for (i=0;i<nxbins;i++) {
      xx[i] = (double)i * Cf / ((double)(nxbins-1));
      ftx[i] = f(xx[i])*pow(theta(xx[i], beta),n)*pow(xx[i],2);
    }
    gsl_spline_init (spline, xx, ftx, nxbins);
    result = gsl_spline_eval_integ (spline, xx[0], xx[nxbins-1], acc);
    gsl_spline_free (spline);
    gsl_interp_accel_free (acc);
    delete [] xx;
    delete [] ftx;
    return result;
  }

  double I3(double Cf, double beta) {// % eqn 28b
    gsl_integration_workspace * w = gsl_integration_workspace_alloc (10000);
    double result, error;
    struct my_func_params params = { delta_rel, n, C, beta, pturbrad };
    gsl_function F;
    F.function = &tx_func;
    F.params = &params;
    gsl_integration_qags (&F, 0.0, Cf, 0, 1e-5, 10000, w, &result, &error);
    //cout << "I3: " << result << endl;
    gsl_integration_workspace_free (w);
    return result;
  }

   double I3spline(double Cf, double beta) {// % eqn 27 {
    int nxbins = 100, i;
    gsl_interp_accel *acc = gsl_interp_accel_alloc ();
    gsl_spline *spline = gsl_spline_alloc (gsl_interp_cspline, nxbins);
    double *xx, *tx, result;
    xx = new double [nxbins];
    tx = new double [nxbins];
    // first need to make an array of values
    if (Cf<0) cout << "Cf error! " << Cf << endl;
    for (i=0;i<nxbins;i++) {
      xx[i] = (double)i * Cf / ((double)(nxbins-1));
      tx[i] = pow(theta(xx[i], beta),n+1.0)*pow(xx[i],2);
    }
    gsl_spline_init (spline, xx, tx, nxbins);
    result = gsl_spline_eval_integ (spline, xx[0], xx[nxbins-1], acc);
    gsl_spline_free (spline);
    gsl_interp_accel_free (acc);
    delete [] xx;
    delete [] tx;
    return result;
  }

  double I3p(double Cf, double beta) {// % eqn 28b
    gsl_integration_workspace * w = gsl_integration_workspace_alloc (10000);
    double result, error;
    struct my_func_params params = { delta_rel, n, C, beta, pturbrad };
    gsl_function F;
    if (pturbrad==1) F.function = &tx_func_p;
    else F.function = &tx_func;
    F.params = &params;
    gsl_integration_qags (&F, 0.0, Cf, 0, 1e-5, 10000, w, &result, &error);
    //cout << "I3: " << result << endl;
    gsl_integration_workspace_free (w);
    if (pturbrad==0) result = result*delta_rel*2.0; // check factor of 2!
    else if (pturbrad==2) result = 0.0;
    return result;
  }

   double I3p_spline(double Cf, double beta) {// % eqn 27 {
     // DO NOT USE THIS FOR NOW
     int nxbins = 100, i;
    gsl_interp_accel *acc = gsl_interp_accel_alloc ();
    gsl_spline *spline = gsl_spline_alloc (gsl_interp_cspline, nxbins);
    double *xx, *tx, result;
    xx = new double [nxbins];
    tx = new double [nxbins];
    // first need to make an array of values
    if (Cf<0) cout << "Cf error! " << Cf << endl;
    for (i=0;i<nxbins;i++) {
      xx[i] = (double)i * Cf / ((double)(nxbins-1));
      if (pturbrad==1) tx[i] = delta_rel*pow(theta(xx[i],beta),n-1.0)*pow(xx[i],2);
      else tx[i] = pow(theta(xx[i], beta),n+1.0)*pow(xx[i],2);
    }
    gsl_spline_init (spline, xx, tx, nxbins);
    result = gsl_spline_eval_integ (spline, xx[0], xx[nxbins-1], acc);
    gsl_spline_free (spline);
    gsl_interp_accel_free (acc);
    delete [] xx;
    delete [] tx;
    return result;
  }


  double L(double Cf, double beta) {// % eqn 27
    gsl_integration_workspace * w = gsl_integration_workspace_alloc (10000);
    double result, error, Sx;
    struct my_func_params params = {delta_rel, n, C, beta, pturbrad };
    gsl_function F;
    F.function = &ttx_func;
    F.params = &params;
    gsl_integration_qags (&F, 0.0, Cf, 0, 1e-5, 10000, w, &result, &error);
    //cout << "L: " << result << endl;
    gsl_integration_workspace_free (w);
    return result;
  }

  double Lspline(double Cf, double beta) {// % eqn 27 {
    int nxbins = 100, i;
    gsl_interp_accel *acc = gsl_interp_accel_alloc ();
    gsl_spline *spline = gsl_spline_alloc (gsl_interp_cspline, nxbins);
    double *xx, *ttl, result;
    xx = new double [nxbins];
    ttl = new double [nxbins];
    // first need to make an array of values
    if (Cf<0) cout << "Cf error! " << Cf << endl;
    for (i=0;i<nxbins;i++) {
      xx[i] = (double)i * Cf / ((double)(nxbins-1));
      ttl[i] =  pow(theta(xx[i], beta), n)*pow(xx[i],2);
    }
    gsl_spline_init (spline, xx, ttl, nxbins);
    result = gsl_spline_eval_integ (spline, xx[0], xx[nxbins-1], acc);
    gsl_spline_free (spline);
    gsl_interp_accel_free (acc);
    delete [] xx;
    delete [] ttl;
    return result;
  }

  double Lvar(double Cf, double beta) {
    // allows different outer pressure boundaries
    float gfact, Cfp, Lc, Lp;
    gfact = g(pressurebound*C) / g(C);
    if (gfact<1.0) cout << "gfact error" << endl;
    Cfp = Cf;
    Lc = Lspline(Cf,beta);
    Lp = Lc;
    // do this in three steps to speed it up
    while (Lp < gfact*Lc) {
      Cfp *= 1.2;
      Lp = Lspline(Cfp,beta);
    }
    Cfp  = Cfp / 1.2;
    while (Lp < gfact*Lc) {
      Cfp *= 1.1;
      Lp = Lspline(Cfp,beta);
    }
    Cfp  = Cfp / 1.1;
    while (Lp < gfact*Lc) {
      Cfp *= 1.02;
      Lp = Lspline(Cfp,beta);
    }
    Cfp *= 1.01/1.02; // settle on half way in between
    return Cfp;
  }

  double Edm(float aniso_beta) { //% Calculation of T + W for dark matter energy transfer (see Bode et al. 09)
    // integrate the kinetic + potential energy
    //w0 = -1*vcmax^2*mass*H(C)/Gmax; % Ostriker et al (05) Eq6a
    double winf, W0Lokas, E;
    winf = (G*pow(mpc/1000.0,3)*pow(mass,2)/ri)*pow(g(C),-2)/2.0; // Lokas & Mamon (01) eq 21
    W0Lokas = -1.0*winf*(1.0 - (1.0/pow(1.0+C,2)) - (2.0*log(1.0+C)/(1.0+C)));
    E = Ek(C, aniso_beta, winf);
    //abs(2*E/W0Lokas) % 2|T|/W (i.e. virial ratio)
    return (W0Lokas + E);
  }

  double Ek(double x, float aniso_beta, double Winf) {//% calculate total kinetic energy T in NFW halo using Lokas & Mamon 01
    double K;
    if (aniso_beta==0.0) {
      K = -3.0 + 3.0/(1.0+x) - 2.0*log(1.0+x) + x*(5.0 + 3.0*log(1.0+x));
      K = K - pow(x,2)*(7.0 + 6.0*log(1.0+x));
      K = K + pow(x,3)*(PI*PI - log(C) - log(x/C) + log(1.0+x) + 3.0*pow(log(1+x),2) + 6.0* gsl_sf_dilog(-1.0*x));
      K = K*0.5;
    }
    else if (aniso_beta==0.5) {
      K = -3.0 + 3.0/(1.0+x) - 3.0*log(1.0+x);
      K = K + 6.0*x*(1.0+log(1.0+x));
      K = K - pow(x,2)*(PI*PI + 3.0*pow(log(1.0+x),2) + 6.0*gsl_sf_dilog(-1.0*x));
      K = K/3;
    }
    else {
      K = -2.0*log(1.0+x);
      K = K + x*(PI*PI/3.0 - 1.0/(1.0+x) + pow(log(1.0+x),2) + 2.0*gsl_sf_dilog(-1.0*x));
      K = K/2.0;
    }
    return K*Winf;
  }

  double setAprime() {
    Aprime = 1.5*(1.0+f_s)*(Gmax()*K(C)*(3.0-4.0*delta_s()) + K_s());
    Aprime +=  -1.0*(Gmax()*eps*f_s*pow(clight/vcmax,2)) - (Gmax()*eps_dm*fabs(Edm(0.0))/(mgas*pow(vcmax,2)));
    return Aprime;
  }

  double setBprime() {
    Bprime = (1.0+f_s)*(S_C(C)/g(C));
    return Bprime;
  }

  double energy_constraint(double beta, double Cf) {
    double f, Lval;
    if (Cf<=0.0) Cf = C/10.0; // (C<0) is unphysical
    f = Aprime + Bprime*(pow(Cf,3) - pow(C,3))/3.0;
    Lval = Lspline(Cf,beta);
    f += -1.0*I2(Cf,beta)/Lval + (1.5*(I3spline(Cf,beta) + I3p(Cf,beta))/(beta*Lval));
    if (isnan(f)) return 100.0;
    return (f);
  }

  double pressure_constraint(double beta, double Cf) {
    double f, Cfp;
    if (beta<=0.0) beta = 0.1;
    if (Cf<=0.0) Cf = C/10.0;
    Cfp = Lvar(Cf, beta);
    f = pow((1.0+f_s)*(S_C(C*pressurebound)/g(C))*beta*Lspline(Cf,beta),(1.0/(1.0+n)));
    if (pturbrad==1) f += -1.0*pow(1.0 + delta_rel*pow(theta(Cfp,beta),-2),1.0/(1.0+n))*theta(Cfp,beta);
    else if (pturbrad==2) f += -1.0* pow(1.0,(1.0/(1.0+n)))*(1.0 - beta*j(Cfp)/((1.0+n)));
    else f += -1.0* pow(1.0+delta_rel,(1.0/(1.0+n)))*(1.0 - beta*j(Cfp)/((1.0+n)*(1.0+delta_rel)));
    if (isnan(f)) {
      return 100.0;
      cout << "Pressure constraint failed! " << endl;
    }
    return (f);
  }

  int solve_gas_model(bool verbose, float tolerance) {
    const gsl_multimin_fminimizer_type *T = gsl_multimin_fminimizer_nmsimplex;
    gsl_multimin_fminimizer *s = NULL;
    gsl_vector *ss, *x;
    gsl_multimin_function F;
    size_t iter = 0;
    int status;
    double size;
    float adiabat_n = n;
    double pt = 0.0;
    pt = (double)pturbrad;
    setAprime();
    setBprime();
    double p[8] = {delta_rel, adiabat_n, C, 0.0, Aprime, Bprime, f_s, pt}; // \beta,_f, C, delta_rel, Ap, Bp

    F.f = gasmod_apply_bc;
    F.n = 2;
    F.params = p;

    /* Starting point */
    x = gsl_vector_alloc (2);
    gsl_vector_set (x, 0, 1.0);
    gsl_vector_set (x, 1, C/2.0);
    /* Set initial step sizes to 1 */
    ss = gsl_vector_alloc (2);
    gsl_vector_set_all (ss, 1.0);
    /* Initialize method and iterate */
    s = gsl_multimin_fminimizer_alloc (T, 2);
    gsl_multimin_fminimizer_set (s, &F, x, ss);
    do
      {
	iter++;
	status = gsl_multimin_fminimizer_iterate(s);
	if (status)
	  break;
	size = gsl_multimin_fminimizer_size (s);
	status = gsl_multimin_test_size (size, tolerance);
	if ((status == GSL_SUCCESS) & verbose)
	  {
	    printf ("converged to minimum at\n");
	    printf ("%5d %10.4e %10.4e f() = %7.3f size = %.3f\n",
		    iter,
		    gsl_vector_get (s->x, 0),
		    gsl_vector_get (s->x, 1),
		    s->fval, size);
	  }
      }
    while (status == GSL_CONTINUE && iter < 100);
    final_beta = gsl_vector_get (s->x, 0);
    final_Cf = gsl_vector_get (s->x, 1);
    setp0rho0(verbose);
    gsl_vector_free(x);
    gsl_vector_free(ss);
    gsl_multimin_fminimizer_free (s);
    return status;
  }

  void setp0rho0(bool verbose) {
    if (verbose) {
      cout << "final_Cf " << final_Cf << endl;
      cout << "final_beta " << final_beta << endl;
    }
    rho0 = mgas / (4.0*PI*pow(ri*1000/mpc,3)*Lspline(final_Cf, final_beta)); // in Msol/Mpc^3
    p0 = rho0*vcmax*vcmax/(final_beta*Gmax()); // in Msol/Mpc^3 (km/s)^2
    T0 = (mmw*m_p*p0/rho0)*(1000.0/eV); // this is in keV
    p0 = p0*1.0e6*m_sun/(eV*1000.0*pow(mpc,3)); // now in keV/m^3
    if (verbose) {
      cout << "final model solution:" << endl;
      cout << "P0      " << "rho0       " << "T0  " << endl;
      cout << p0 << " " << rho0 << " " << T0  << " "<<mgas<<endl;
    }
  }

  void initialize_profiles(float minr, float maxr, float dr, float ellmin, float ellmax, float dlfrac) {
    int i;
    float dtheta, dl_ell_10;
    float c500=1.177;
    minr = minr*radius; //in mpc
    maxr = maxr*radius;  //in mpc
    dr = dr*radius;  //in mpc
    if (dlfrac < 1) dl_ell_10 = dlfrac/log(10.0);
    nrads = (int) ceil((maxr-minr)/dr)+1;

    if (dlfrac == 0.0) nell = 1;
    if(dlfrac < 1 && dlfrac > 0.0) nell = (int)ceil((log10(ellmax/ellmin)/dl_ell_10))+1;
    if(dlfrac >= 1) nell= (int) ceil((ellmax-ellmin)/dlfrac)+1;

    x = new float [nrads];
    ysz = new double [nrads];
    rhogas= new double [nrads];
    Tsz= new double [nrads];
    Ksz= new double [nrads];
    rr= new double [nrads];
    k= new float [nrads];

    for (i=0;i<nrads;i++) {
      x[i] = minr + (float)i*dr;
      k[i]= 2.0*PI/x[i]*radius/c500;
    }

    fft_ysz = new double [nell];
    ell = new double [nell];
    for (i=0;i<nell;i++) {
      if(dlfrac<1) {
        ell[i] = log10(ellmin) + ((float)i*dl_ell_10);
        ell[i] = ceil(pow(10.0, ell[i]));
        }
      if(dlfrac >= 1)  ell[i] = ellmin + (float) i*dlfrac;
     }
  }

  int get_nrads() {
    return nrads;
  }

  int get_nell() {
    return nell;
  }

  void clear_profiles() {
    delete[] x;
    delete[] ysz;
    delete[] fft_ysz;
    delete[] ell;
    delete[] rhogas;
    delete[] rr;
    delete[] Tsz;
   delete[] Ksz;
 }

  double* get_ell() {
    return &ell[0];
  }

  double* get_yfft() {
    return &fft_ysz[0];
  }

 double* get_ysz() {
    return &ysz[0];
  }


  float* get_k(){  return &k[0];}
  double* get_x() {  return (double*)&x[0];}
 double* get_P() {  return &ysz[0]; }
 double* get_T(){ return &Tsz[0];}
 double* get_rhogas(){ return &rhogas[0];}
 double* get_K() {  return &Ksz[0]; }
 double* get_xx(){ return &rr[0]; }

  void print_profiles() {
    for (int i = 0;i<nrads;i++) {
      cout << x[i] << " " << ysz[i] << endl;
    }
  }

  void print_profiles(float scale_rad) {
    for (int i = 0;i<nrads;i++) {
      cout << x[i]/scale_rad << " " << ysz[i] << endl;
    }
  }

  void print_fft_profiles() {
    for (int i = 0;i<nell;i++) {
      cout << ell[i] << " " << fabs(fft_ysz[i]) << endl;
    }
  }

  void save_fft_profiles( ofstream &catfile) {
   for (int i = 0;i<nell;i++) {
     //catfile << ell[i] << "\t" << fft_ysz[i] << endl;
    }
  }

  double* calc_3d_sz_profile(float R500) {
    float units = mpc*sigma_T/me_csq;
    double xx;
    int i;
    for (i=0;i<nrads;i++) {
      xx = (double)x[i]/(1000.0*ri/mpc); // need to sort out the stupid units on ri
      ysz[i] =  (double)units*p0*pow(theta(xx,final_beta),(n+1.0))/mu_e; // should the mu_e be here?
      if (pturbrad==2) ysz[i] = ysz[i]*(1.0 - delta_rel*pow(x[i]*(1000.0*ri/mpc) / R500, delta_rel_n));
    }
    return &ysz[0];
  }


  double* calc_electron_pressure_profile(float R500){
    double xx;
    int i;
    for (i=0;i<nrads;i++) {
      xx = (double)x[i]/(1000.0*ri/mpc); // need to sort out the stupid units on ri
      ysz[i] =  (double)mmw*p0*pow(theta(xx,final_beta),(n+1.0))/mu_e;
      if (pturbrad==2) ysz[i] = ysz[i]*(1.0 - delta_rel*pow(x[i]*(1000.0*ri/mpc) / R500, delta_rel_n));
    }
    return &ysz[0];
  }

 double thermal_pressure_outer_rad() {
    // returns outermost physical radius for thermal pressure profiles (i.e. the point where the thermal pressure
    // goes to zero (in units of rvir)
    return pow((1.0 / delta_rel), 1.0/delta_rel_n) * R500toRvir; // last factor converts from units of R500 to units of Rvir
  }


double calc_Mhse_Mtot_ratio(float R500) {
   double delx=0.1;
   double rplus= (R500 + delx)/(1000.0*ri/mpc);
   double rminus= (R500 - delx)/(1000.0*ri/mpc);
   double diff_tot= (theta(rplus, final_beta)- theta(rminus, final_beta))/(2.0*delx/(1000.0*ri/mpc));
   //cout<< final_beta<<endl;

    return 1.0 - delta_rel - delta_rel*delta_rel_n/diff_tot*pow(theta(R500/(1000.0*ri/mpc), final_beta), 1)/(n+1)/R500*(1000.0*ri/mpc);

}

 double* calc_gas_pressure_profile(double rcutoff, double xin, double xfinal, int xbinnum, float R500, float P500) {
  double xx, delx, result, xfinal_i;
    int i;
    double Vol[250], r[250], yy[250];
    xin= xin*R500;
    xfinal_i= xfinal*R500;
    delx= log(xfinal_i/xin)/xbinnum;
    // P500=1.65e-3*pow(0.7,2);
    for (i=0;i<xbinnum;i++) {
      xx = (double)pow(2.7183, log(xin)+i*delx)/(1000.0*ri/mpc);
      ysz[i] =  (double)mmw*p0/1e6*pow(theta(xx,final_beta),(n+1.0))/mu_e;//*xx*xx; //keV/cm^3
      if (pturbrad==2) ysz[i] = ysz[i]*(1.0 - delta_rel*pow(xx*(1000.0*ri/mpc)/R500, delta_rel_n));
      r[i]= xx*(1000.0*ri/mpc)/R500;
      Vol[i]= xx*xx;
      cout<< i<<" "<<r[i]*0.71 <<" "<< pow(r[i]*0.71,3)*ysz[i]/P500<<endl;
}

    return &ysz[0];
  }

double* calc_gas_temp_profile(double rcutoff, double xin, double xfinal, int xbinnum, float R500) {
  double xx, delx;
    int i;

    xin= xin*rcutoff*radius;
    xfinal= xfinal*rcutoff*radius;
    delx= log(xfinal/xin)/(xbinnum-1);
    for (i=0;i<xbinnum;i++) {
      xx = (double)pow(2.7183, log(xin)+i*delx)/(1000.0*ri/mpc);
      Tsz[i] =  (double)T0*theta(xx,final_beta); //keV
    if (pturbrad==2) Tsz[i] = Tsz[i]*(1.0 - delta_rel*pow(xx*(1000.0*ri/mpc)/R500, delta_rel_n));
      x[i]= xx;
      //cout<< xx*(1000.0*ri/mpc)/R500 <<" " << Tsz[i]<< endl;
   }
    return &Tsz[0];
  }

 double* calc_gas_profile(double rcutoff, double xin, double xfinal, int xbinnum, float R500) {
  double xx, delx;
    int i;
    xin = xin*rcutoff*radius;
    xfinal = xfinal*rcutoff*radius;
    delx = log(xfinal/xin)/(xbinnum-1);

    for (i=0;i<xbinnum;i++) {
      xx = (double)pow(2.7183, log(xin)+i*delx)/(1000.0*ri/mpc);
      rhogas[i] =  (double)mmw*rho0*pow(theta(xx,final_beta), n)/mu_e/m_p/pow(mpc,3)/1.e6*m_sun; //Msol/Mpc^3
      x[i]= xx;
      //cout<< xx*(1000.0*ri/mpc)/R500 <<" " << rhogas[i]<< endl;
    }
   return &rhogas[0];
  }

double calc_gas_pressure(double r, float R500){
  double xx, ngas, T, Pgas;

  xx = r/(1000.0*ri/mpc);
  ngas = rho0*pow(theta(xx,final_beta), n)/m_p/mmw/pow(mpc,3)/1.e6*m_sun; // cm^-3
  T = T0*theta(xx,final_beta)*(1.0 - delta_rel*pow(xx*(1000.0*ri/mpc)/R500, delta_rel_n)); //keV

  Pgas = ngas*T; // keV/cm^3
  return Pgas;
}

double calc_gas_density(double r, float R500){
  double xx, rhogas;

  xx = r/(1000.0*ri/mpc);
  rhogas = rho0*pow(theta(xx,final_beta), n)/pow(mpc,3)/1.e3*m_sun; // g/cm^3

  return rhogas;
}

double calc_Y(float R500, float Rvir, double Rmax){
    int nx = 1000;
    double res, x, w;
    gsl_integration_glfixed_table *t;

    t = gsl_integration_glfixed_table_alloc(nx);

    res = 0.0;
    for(int i=0;i<nx;i++){
        gsl_integration_glfixed_point(0.0, 1.0, i, &x, &w, t);
        res += w*4.0*PI*x*x*calc_gas_pressure(x*Rmax, R500);
    }
    res *= pow(Rmax*mpc*1e2, 3.0);
    gsl_integration_glfixed_table_free(t);

    return res;
}

double calc_shell_Y(float R500, float Rvir, double rm, double rp){
    int nx = 100;
    double res, x, w, r;
    gsl_integration_glfixed_table *t;

    t = gsl_integration_glfixed_table_alloc(nx);

    res = 0.0;
    for(int i=0;i<nx;i++){
        gsl_integration_glfixed_point(0.0, 1.0, i, &x, &w, t);
        r = (rp-rm)*x+rm; // in Mpc
        res += w*4.0*PI*r*r*calc_gas_pressure(r, R500);
    }
    res *= pow(mpc*1e2, 3.0)*(rp-rm);
    gsl_integration_glfixed_table_free(t);

    return res;
}

double* calc_gas_entropy_profile(double rcutoff, double xin, double xfinal, int xbinnum, float R500) {
  double xx, delx;
  int i;
  double convert= m_sun/pow(mpc,3.)/m_p*1.0e-6;
  //cout<< "beta="<< xin<< " "<<xfinal<<endl;
  xin= xin*rcutoff*radius;
  xfinal= xfinal*rcutoff*radius;
  delx= log(xfinal/xin)/(xbinnum-1);
//cout<< xin<<" "<<xfinal<< R500<<" "<<rcutoff<<" "<<radius<<" "<<1000.0*ri/mpc<<endl;
    for (i=0;i<xbinnum;i++) {
      xx = (double)pow(2.7183, log(xin)+i*delx)/(1000.0*ri/mpc);
      Ksz[i] =  (double)T0*theta(xx,final_beta)/pow(mmw*rho0*pow(theta(xx,final_beta), n)/mu_e*convert,2./3.); //keV.cm^2
   //ysz[i]= mmw*p0/1e6*pow(theta(xx,final_beta),(n+1.0))/mu_e/pow(mmw*rho0*pow(theta(xx,final_beta), n)/mu_e*convert,5./3.);
   if (pturbrad==2) Ksz[i] = Ksz[i]*(1.0 - delta_rel*pow(xx*(1000.0*ri/mpc)/R500, delta_rel_n));
      x[i]= xx;
      //cout<< xx*(1000.0*ri/mpc)/R500 <<" " << ysz[i]<< endl;
  }

    return &Ksz[0];
  }

double* calc_x(double rcutoff, double xin, double xfinal, int xbinnum) {
   float xx, delx;
    int i;
    //xin= xin*rcutoff*radius;
    //xfinal= xfinal*rcutoff*radius;
    delx= log(xfinal/xin)/(xbinnum-1);
    for (i=0;i<xbinnum;i++) {
      xx = pow(2.7183, log(xin)+i*delx);//(1000.0*ri/mpc);
      rr[i]= xx;
    }
   return &rr[0];
  }

  double* calc_ellspace_sz_profile(double rcutoff, double ang_diam_z, float redshift, float R500, bool verbose) {
    double units = mpc*sigma_T/me_csq;
    // note rcutoff is in units of Rvir
    gsl_integration_workspace * w = gsl_integration_workspace_alloc (10000);
    double result, error, upperlim = rcutoff*C, elli = ang_diam_z/(1000.0*ri/mpc);
    double pt = 0.0;
    pt= (double)pturbrad;
    double params[9] = {delta_rel, n, C, final_beta, 0.0, elli, pt, delta_rel_n, R500/(1000.0*ri/mpc)};
    gsl_function F;
    int i;
    if (pturbrad==2) upperlim = min(upperlim, thermal_pressure_outer_rad() * C);
    F.function = &yfft_func;
    F.params = &params;
    for (i=0;i<nell;i++) {
      params[4] = ell[i];
      gsl_integration_qags (&F, 0.0, upperlim, 0, 1e-7, 10000, w, &result, &error);
      result = result*4.0*PI*(1000.0*ri/mpc)/elli/elli;
      fft_ysz[i] = (double)mmw*units*result*p0/mu_e;
    }
    gsl_integration_workspace_free (w);
    //check_unbound(redshift, verbose);
    return &fft_ysz[0];
  }

  double* calc_ellspace_sz_profile_spline(double rcutoff, double ang_diam_z, float redshift, float R500, bool verbose) {
    double units = mpc*sigma_T/me_csq;
    // note rcutoff is in units of Rvir
    double result, error, upperlim = rcutoff*C, elli = ang_diam_z/(1000.0*ri/mpc);
    int nxbins = 100, i, j;
    gsl_interp_accel *acc = gsl_interp_accel_alloc ();
    gsl_spline *spline = gsl_spline_alloc (gsl_interp_cspline, nxbins);
    double *xx, *yy;
    xx = new double [nxbins];
    yy = new double [nxbins];
    // now make absolutely sure thermal pressure never goes negative
    if (pturbrad==2) upperlim = min(upperlim, thermal_pressure_outer_rad() * C);

    for (j=0;j<nxbins;j++) xx[j] = (double)j * upperlim / ((double)(nxbins-1));
    yy[0] = 0.0;
    for (i=0;i<nell;i++) {
      for (j=1;j<nxbins;j++) {
	yy[j] = pow(theta(xx[j],final_beta),n+1.0)*xx[j]*xx[j]*sin(ell[i]*xx[j]/elli)/(ell[i]*xx[j]/elli);
	if (pturbrad==2) {
	  yy[j] = yy[j]*(1.0 - delta_rel*pow(xx[j]*(1000.0*ri/mpc)/R500, delta_rel_n));
	  //if (yy[j]<0.0) yy[j] = 0.0;
	}
      }
      gsl_spline_init (spline, xx, yy, nxbins);
      result = gsl_spline_eval_integ (spline, xx[0], xx[nxbins-1], acc);
      result = result*4.0*PI*(1000.0*ri/mpc)/elli/elli;
      fft_ysz[i] = (double)mmw*units*result*p0/mu_e;
    }
    gsl_spline_free (spline);
    gsl_interp_accel_free (acc);
    delete[] xx;
    delete[] yy;
    return &fft_ysz[0];
  }

 double* calc_ellspace_nfw_profile_spline(double ang_diam_z, float redshift, float Rvir) {

   double Si_result, Ci_result, error, elli = ang_diam_z;
    int nxbins = 1000, i, j;
    gsl_interp_accel *acc = gsl_interp_accel_alloc ();
    gsl_spline *spline = gsl_spline_alloc (gsl_interp_cspline, nxbins);
    double *xx, *Si, *Ci;
    xx = new double [nxbins];
    Si = new double [nxbins];
    Ci= new double [nxbins];
    double xmin=1e-3;
    double xmax=1000;
    double xbin= log(xmax/xmin)/(nxbins-1);
    // now make absolutely sure thermal pressure never goes negative

    for(j=0; j< nxbins; j++){
      xx[j]=xmin*exp(xbin*j);
      Si[j]= sin(xx[j])/xx[j];
      Ci[j]= cos(xx[j])/xx[j];
      // cout<<xx[j]<<" "<<Si[j]<<" "<<Ci[j]<<endl;
     }
    for (i=0;i<nell;i++) {
      double upperlimit=ell[i]/elli*Rvir/C*(1+C);
      double lowerlimit= ell[i]/elli*Rvir/C;
      // cout<<upperlimit<<" "<<lowerlimit<<endl;
      gsl_spline_init (spline, xx, Si, nxbins);
      Si_result = gsl_spline_eval_integ (spline, lowerlimit,upperlimit, acc);
      gsl_spline_init (spline, xx, Si, nxbins);
      Ci_result= gsl_spline_eval_integ (spline, lowerlimit,upperlimit, acc);

      fft_ysz[i] = (double) 1.0/(log(1+C)-C/(1+C))*(sin(lowerlimit)*Si_result-sin(C*lowerlimit)/upperlimit+cos(lowerlimit)*Ci_result);
      //cout<<ell[i]<<" "<<fft_ysz[i]<<endl;
    }
    gsl_spline_free (spline);
    gsl_interp_accel_free (acc);
    delete[] xx; delete[] Si; delete[] Ci;
    return &fft_ysz[0];
 }


  double* calc_ellspace_arnaud_profile(double rcutoff, double ang_diam_z, float M500, float R500, float Efact, float hubble70, float hydrofact, float z, float A, float B, float C, float A1, float B1, float C1) {
    double press_to_sz = sigma_T/me_csq;
    float Pnorm, P0, alpha, beta, gamma, c500, alphap;
    // note rcutoff is in units of R500 here
    c500 = /*1.083;*/ 1.083;
    alpha = /*1.4063;*/1.4063/pow(1+z, A1);
    beta = /*5.4096;*/5.4096/pow(1+z, B1);
      gamma = /*0.3798;*/0.3798/pow(1+z, C1);
      alphap = 0.12;
    Pnorm = get_arnaud_P500(M500, Efact, hubble70, alphap, hydrofact);
    gsl_integration_workspace * w = gsl_integration_workspace_alloc (10000);
    double xx, result, error, upperlim = 2.0*rcutoff*c500, elli = ang_diam_z/(R500/c500);
    double params[6] = {c500, alpha, beta, gamma, 0.0, elli};
    gsl_function F;
    int i;
    F.function = &arnaud_func;
    F.params = &params;
    result = 0.0;
    for (i=0;i<nell;i++) {
      params[4] = ell[i];
      gsl_integration_qags (&F, 0.0, upperlim, 0, 1e-7, 10000, w, &result, &error);
      result = result*4.0*PI*(R500/c500)*mpc/elli/elli;
      fft_ysz[i] = (double)press_to_sz*result*Pnorm;
    }
    gsl_integration_workspace_free (w);
    return &fft_ysz[0];
  }


  double* calc_kspace_sz_profile(double rcutoff, double ang_diam_z, float redshift, float R500, bool verbose) {
    double units = mpc*sigma_T/me_csq;
    // note rcutoff is in units of Rvir
    gsl_integration_workspace * w = gsl_integration_workspace_alloc (10000);
    double result, error, upperlim = rcutoff*C, elli = ang_diam_z/(1000.0*ri/mpc);
    double pt = 0.0;
    pt= (double)pturbrad;
    double params[9] = {delta_rel, n, C, final_beta, 0.0, elli, pt, delta_rel_n, R500/(1000.0*ri/mpc)};
    gsl_function F;
    int i;
    if (pturbrad==2) upperlim = min(upperlim, thermal_pressure_outer_rad() * C);
    F.function = &yfft_func_k;
    F.params = &params;
    for (i=0;i<nrads;i++) {
      params[4] = k[i];
      gsl_integration_qags (&F, 0.0, upperlim, 0, 1e-7, 10000, w, &result, &error);
      result = result/2.0/PI/PI; //*4.0*PI*(1000.0*ri/mpc)/elli/elli;
      ysz[i] = (double)result; //mmw*units*result*p0/mu_e;
    }
    gsl_integration_workspace_free (w);
    //check_unbound(redshift, verbose);
    return &ysz[0];
  }


 double* calc_kspace_arnaud_profile(double rcutoff, double ang_diam_z, float M500, float R500, float Efact, float hubble70, float hydrofact) {
    double press_to_sz = sigma_T/me_csq;
    float Pnorm, P0, alpha, beta, gamma, c500, alphap;
    // note rcutoff is in units of R500 here
    c500 = 3.2;//1.177;
    alpha = 1.0510;
    beta = 2.5;//5.4905;
    gamma = 0.3081;
    alphap = 0.12;
    Pnorm = get_arnaud_P500(M500, Efact, hubble70, alphap, hydrofact);
    gsl_integration_workspace * w = gsl_integration_workspace_alloc (10000);
    double xx, result, error, upperlim = 2.0*rcutoff*c500;
    double params[5] = {c500, alpha, beta, gamma, 0.0};
    gsl_function F;
    int i;
    F.function = &arnaud_func_k;
    F.params = &params;
    result = 0.0;
    for (i=0;i<nrads;i++) {
      params[4] = k[i];
      gsl_integration_qags (&F, 0.0, upperlim, 0, 1e-7, 10000, w, &result, &error);
      result = result/2.0/PI/PI;//*pow(rcutoff*radius/c500,3.0);
      ysz[i] = (double)result;//*Pnorm;
    }
    gsl_integration_workspace_free (w);
    return &ysz[0];
  }


 void project_arnaud_profile(double rcutoff, float M500, float R500, float Efact, float hubble70, float hydrofact, double *r, double *ysz) {
    double press_to_sz = sigma_T/me_csq;
    double Pnorm, P0, alpha, beta, gamma, c500, alphap;
    // note rcutoff is in units of R500 here
    c500 = 1.177;
    alpha = 1.0510;
    beta = 5.4905;
    gamma = 0.3081;
    alphap = 0.12;
    Pnorm = get_arnaud_P500(M500, Efact, hubble70, alphap, hydrofact);
    gsl_integration_workspace * w = gsl_integration_workspace_alloc (10000);
    double xx, result, error, upperlim = 2.0*rcutoff*c500;
    double params[5] = {c500, alpha, beta, gamma, 0.0};
    gsl_function F;
    int i;
    F.function = &proj_arnaud_func;
    F.params = &params;
    for (i=0;i<nrads;i++) {
      xx = (double)(x[i]*c500/R500);
      r[i]= xx*R500/c500;//*(1000.0*ri/mpc);
      params[4] = xx;
      if (xx<= rcutoff*c500) {
	gsl_integration_qags (&F, xx, upperlim, 0, 1e-7, 10000, w, &result, &error);
	ysz[i] = (double)2.0*press_to_sz*(R500/c500)*mpc*result*Pnorm;//*(1000.0*ri/mpc);
      }
      else ysz[i] = 0.0;
    }
    gsl_integration_workspace_free (w);
    //return &fft_ysz[0];
  }

  float get_arnaud_P500(float M500, float Efact, float hubble70, float alphap, float hydrofact) {
    float P0, Pnorm;
    P0 =  /*8.403*/3.2015/pow(hubble70,1.5);
    Pnorm = 1.65e-3*pow(Efact,8.0/3.0)*pow(hubble70*M500*hydrofact/3.0e14,0.6667 + alphap)*pow(hubble70,2); // units are keV/cm^3
    Pnorm = Pnorm*P0*1.0e6; // keV/m^3
    return Pnorm;
  }


 float get_arnaud_P500_vary(float M500, float Efact, float hubble70, float alphap, float hydrofact, float z, float A, float B, float C) {
    float P0, Pnorm;
    P0 =  8.403/pow(hubble70,1.5);
    Pnorm = A*1.65e-3*pow(Efact,8.0/3.0)*pow(hubble70*M500*hydrofact/3.0e14,(0.6667 + alphap)*B)*pow(hubble70,2)/pow(1+z, C); // units are keV/cm^3
    Pnorm = Pnorm*P0*1.0e6; // keV/m^3
    return Pnorm;
  }

 void KS02(double rcutoff, float z, float mass, float fb, float ang_d, float hubble, double *r, double *ysz) {
    double press_to_sz = sigma_T/me_csq*mpc;
      double rho0, T0, eta, gamma, B;
      double rvir= (1000.0*ri/mpc)*C;
    // note rcutoff is in units of R500 here
      C=10/(1+z)*pow(mass/2.2e12, -0.2);
    gamma = 1.137 + 8.94e-2*log(C/5) - 3.68e-3*(C - 5);
    eta = 2.235 + 0.202*(C - 5)-1.16e-3*pow(C - 5,2);
    B = 3*pow(eta,-1)*(gamma - 1)/gamma*pow(log(1 + C)/C - 1/(1 + C),-1);

    rho0=7.96e13/1.0e15*fb*mass/pow(rvir,3)*C*C/pow(1+C,2)*pow(log(1+C)- C/(1+C),-1)*pow(1 - B*(1 - log(1 + C)/C),-1/(gamma - 1));
    T0 = eta*8.8*mass/1e15/rvir;

    gsl_integration_workspace * w = gsl_integration_workspace_alloc (10000);
    double xx, result, error, upperlim = C*rcutoff;
    double params[5] = {C, 0, 0,0,0};
    gsl_function F;
    int i;
    F.function = &proj_KS02_func;
    F.params = &params;
    for (i=0;i<nrads;i++) {
      xx = (double)(x[i]*C/rvir);
      r[i]= xx*rvir/C;
      params[4] = xx;
      if (xx<= upperlim) {
	gsl_integration_qags (&F, xx, upperlim, 0, 1e-7, 10000, w, &result, &error);
	ysz[i] = (double)2.0*press_to_sz*rvir/C*55.0*1e3*rho0*T0/1e14/8.0*result;
	//ysz[i]= (double)1.04e-4*rvir*55.0/50.0*rho0*T0/(pow(10.0,14.0))/8.0*result;
	//(double)2.0*press_to_sz*(R500/c500)*mpc*result*Pnorm;//*(1000.0*ri/mpc);
      }
      else ysz[i] = 0.0;
    }
    gsl_integration_workspace_free (w);
    //return &fft_ysz[0];
  }


  void check_unbound(float z, bool verbose) {
    // sets fft signal = 0 if model appears to result in unbound clusters
    int i;
    if ((final_Cf/C - 1.0) > 0.8) {
      if (verbose) cout << "Cluster, M = " << mass << " Msol, redshift = " << z << ", is unbound" << endl;
      for (i=0;i<nell;i++) {
	fft_ysz[i] = 0.0;
      }
    }
  }


  void calc_2d_sz_profile(double rcutoff, float R500, double *r, double* ysz) {
    double units = mpc*sigma_T/me_csq;
    // note rcutoff is in units of Rvir
    gsl_integration_workspace * w = gsl_integration_workspace_alloc (10000);
    double xx, result, error, upperlim = rcutoff*C;
    double pt = 0.0;
    pt= (double)pturbrad;
    double params[8] = {delta_rel, n, C, final_beta, 0.0, pt, delta_rel_n, R500/(1000.0*ri/mpc)};
    gsl_function F;
    int i;
    F.function = &yproj_func;
    F.params = &params;

    for (i=0;i<nrads;i++) {
      xx = (double)(x[i]/(1000.0*ri/mpc));
      r[i]= xx*(1000.0*ri/mpc);//R500;
      if (xx <= upperlim) {
	params[4] = xx;
	gsl_integration_qags (&F, xx, upperlim, 0, 1e-7, 10000, w, &result, &error);
	ysz[i] = (double)units*result*p0*2.0*(1000.0*ri/mpc)/mu_e;
      }
      else ysz[i] = 0.0;
      // cout<<ysz[i]<<" "<<p0<<endl;
    }

    gsl_integration_workspace_free (w);
    //return &ysz[0];
  }

double calc_2d_gas_profile(double rcutoff, float R500, double *r, double* ysz) {
    double units = 2.05e-3; //1006.2828 trac et al
    // note rcutoff is in units of Rvir= R500/Rvir
    gsl_integration_workspace * w = gsl_integration_workspace_alloc (10000);
    double xx, result, error, upperlim = rcutoff*C;
    double pt = 0.0;
    pt= (double)pturbrad;
    double params[8] = {delta_rel, n, C, final_beta, 0.0, pt, delta_rel_n, R500/(1000.0*ri/mpc)};
    gsl_function F;
    int i;

    F.function = &gasproj_func;
    F.params = &params;
    for (i=0;i<nrads;i++) {
      xx = (double)(x[i]/(1000.0*ri/mpc));
      r[i]= xx*(1000.0*ri/mpc);//R500;
      if (xx <= upperlim) {
	params[4] = xx;
	gsl_integration_qags (&F, xx, upperlim, 0, 1e-7, 10000, w, &result, &error);
	ysz[i] = (double)result*sigma_T*mmw/mu_e*m_sun*rho0*2.0*(1000.0*ri/mpc)/m_p/pow(mpc,2)/clight;//1e3;  //mmw*rho0*pow(theta(xx,final_beta), n)/mu_e/m_p/
      }
      else ysz[i] = 0.0;
      // cout<<r[i]<<" "<<ysz[i]<<" "<<rho0<<endl;
    }

    gsl_integration_workspace_free (w);
    //return &ysz[0];
  }

  double calc_total_int_szflux(double rcutoff, float R500) {
    double units = p0*4.0*PI*mpc*sigma_T/me_csq*pow(1000.0*ri/mpc*C,3)/mu_e;
    //cout<<units<<endl;
    // note rcutoff is in units of Rvir
    gsl_integration_workspace * w = gsl_integration_workspace_alloc (10000);
    double result, error;
    double pt = 0.0;
    pt= (double)pturbrad;
    double params[8] = {delta_rel, n, C, final_beta, 0.0, pt, delta_rel_n, R500/(1000.0*ri/mpc)};
    gsl_function F;
    int i;
    F.function = &yint_func;
    F.params = &params;
    gsl_integration_qags (&F, 0.0, rcutoff, 0, 1e-7, 10000, w, &result, &error);
    Ytot = (double)units*result;
    gsl_integration_workspace_free (w);
    return Ytot;
  }


double calc_mgas500(double rcutoff) {
   double units = rho0*4.0*PI*pow(1000.0*ri/mpc,3);
    // note rcutoff is in units of Rvir= R500/Rvir
    double mgas500;
    gsl_integration_workspace * w = gsl_integration_workspace_alloc (10000);
    double result, error;
    double pt = 0.0;
    if (pturbrad) pt=1.0;
    double params[6] = {delta_rel, n, C, final_beta, f_s, pt};
    gsl_function F;
    int i;
    F.function = &mgas500_func;
    F.params = &params;
    gsl_integration_qags (&F, 0.0, rcutoff*C, 0, 1e-7, 10000, w, &result, &error);
    mgas500 = (double) units*result;
    gsl_integration_workspace_free (w);
    return mgas500;
  }

  void set_ysz_betamod(float y0, float thetac, float beta, float rcutoff, float ang_diam_z) {
    //thetac = thetac/60.0*PI/180.0;
    float xi;
    rcutoff = rcutoff*radius/ang_diam_z*180.0*60.0/PI;
    for (int i = 0;i<nrads;i++) {
      xi = (x[i] / ang_diam_z)*180.0*60/PI;// in arcmins
      //x[i] = (float)i*0.1;
      if (xi <=rcutoff) ysz[i] = y0*pow(1.0 + pow(xi/thetac,2), -1.0*(3.0*beta-1.0)/2.0);
      else ysz[i] = 0.0;
      //x[i] = (float)i*0.1;
      //ysz[i] = y0*exp(-1.0*PI*x[i]*x[i]/thetac/thetac);
    }
    rcutoff = rcutoff/60.0/180.0*PI; // switch to radians
    thetac = thetac/60.0/180.0*PI; // switch to radians
    Ytot = 2.0*PI*0.5*pow(thetac,2)*log(1.0 + pow(rcutoff/thetac,2)); // this is for beta =1
  }

};

// functions for integrals go here

double ttx_func(double x, void * p) {
  struct my_func_params * params = (struct my_func_params *)p;
  float n = params->b;
  float C = params->c;
  double beta = params->d;
  float delta_rel = params->a;
  int pturbrad = params->e;
  float delta_rel_n= params-> f;
  gas_model gmod(delta_rel, n, C, 0.0, 0.0, 0.0, pturbrad, delta_rel_n);
  double ff = pow(gmod.theta(x, beta), n)*pow(x,2);
  return ff;
}

double tx_func(double x, void * p) {
  struct my_func_params * params = (struct my_func_params *)p;
  float n = params->b;
  float C = params->c;
  double beta = params->d;
  float delta_rel = params->a;
  int pturbrad = params->e;
  float delta_rel_n= params-> f;
  gas_model gmod(delta_rel, n, C, 0.0, 0.0, 0.0, pturbrad, delta_rel_n);
  double ff = pow(gmod.theta(x, beta),n+1.0)*pow(x,2);
  return ff;
}

double tx_func_p(double x, void * p) {
  struct my_func_params * params = (struct my_func_params *)p;
  float n = params->b;
  float C = params->c;
  double beta = params->d;
  float delta_rel = params->a;
  int pturbrad = params->e;
  float delta_rel_n= params-> f;
  gas_model gmod(delta_rel, n, C, 0.0, 0.0, 0.0, pturbrad, delta_rel_n);
  double ff = delta_rel*pow(gmod.theta(x,beta),n-1.0)*pow(x,2);
  return ff;
}


double ftx_func(double x, void * p) {
  struct my_func_params * params = (struct my_func_params *)p;
  float n = params->b;
  float C = params->c;
  double beta = params->d;
  float delta_rel = params->a;
  int pturbrad = params->e;
  float delta_rel_n= params-> f;
  gas_model gmod(delta_rel, n, C, 0.0, 0.0, 0.0, pturbrad, delta_rel_n);
  double ff = gmod.f(x)*pow(gmod.theta(x, beta),gmod.n)*pow(x,2);
  return ff;
}

double sx_func (double x, void * params) {
    double f = (x - (1.0+x)*log(1.0+x)) / (pow(x,3)*pow(1.0+x,3));
    return f;
}

double ss_func(double x, void * params) {
  double C = *(double *) params;
  gas_model gmod(0.0, 0.0, C, 0.0, 0.0, 0.0, 0, 0.0);
  double f = gmod.S_cx(x)*pow(x,2);
  return f;
}

double fx_func(double x, void * params) {
  double C = *(double *) params;
  gas_model gmod(0.0, 0.0, C, 0.0, 0.0, 0.0, 0, 0.0);
  double g = gmod.f(x)*x/pow(1.0+x,2);
  return g;
}

double yproj_func(double x, void * p) {
  double *params = (double *) p;
  float n = (float)params[1];
  float C = (float)params[2];
  float delta_rel = (float)params[0];
  double beta = params[3];
  double R = params[4];
  int pturbrad = (int)params[5];
  float delta_rel_n = params[6];
  float R500_div_ri = params[7];
  gas_model gmod(delta_rel, n, C, 0.0, 0.0, 0.0, pturbrad, delta_rel_n);
  double y;
  if ((x-R)<0.01) y = 0.0;
  else  y = pow(gmod.theta(x,beta),gmod.n+1.0)*x/pow(x*x - R*R,0.5);
  if (pturbrad==2) y = y*(1.0 - delta_rel*pow(x/R500_div_ri, delta_rel_n));
  return y;
}

double yfft_func(double x, void * p) {
  double *params = (double *) p;
  double n = (double)params[1];
  double C = (double)params[2];
  double delta_rel = (double)params[0];
  double beta = params[3];
  double ell = params[4];
  double elli = params[5];
  int pturbrad = (int)params[6];
  float delta_rel_n = params[7];
  float R500_div_ri = params[8];
  gas_model gmod(delta_rel, n, C, 0.0, 0.0, 0.0, pturbrad, delta_rel_n);
  double y;
  y = pow(gmod.theta(x,beta),gmod.n+1.0)*x*x*sin(ell*x/elli)/(ell*x/elli);
  if (pturbrad==2) y = y*(1.0 - delta_rel*pow(x/R500_div_ri, delta_rel_n));
  return y;
}

double arnaud_func(double x, void * p) {
  double *params = (double *) p;
  double c500 = (double)params[0];
  double alpha = (double)params[1];
  double beta = (double)params[2];
  double gamma = (double)params[3];
  double ell = (double)params[4];
  double elli = (double)params[5];
  double y;
  y = (1.0/ (pow(x,gamma)*pow(1.0 + pow(x,alpha),(beta-gamma)/alpha)))*x*x*sin(ell*x/elli)/(ell*x/elli);
  return y;
}

double yfft_func_k(double x, void * p) {
  double *params = (double *) p;
  double n = (double)params[1];
  double C = (double)params[2];
  double delta_rel = (double)params[0];
  double beta = params[3];
  double k = params[4];
  //double elli = params[5];
  int pturbrad = (int)params[5];
  float delta_rel_n = params[6];
  float R500_div_ri = params[7];
  gas_model gmod(delta_rel, n, C, 0.0, 0.0, 0.0, pturbrad, delta_rel_n);
  double y;
  y = pow(gmod.theta(x,beta),gmod.n+1.0)*x*x*sin(k*x)/(k*x);
  if (pturbrad==2) y = y*(1.0 - delta_rel*pow(x/R500_div_ri, delta_rel_n));
  return y;
}

double arnaud_func_k(double x, void * p) {
  double *params = (double *) p;
  double c500 = (double)params[0];
  double alpha = (double)params[1];
  double beta = (double)params[2];
  double gamma = (double)params[3];
  double k = (double)params[4];
  //double elli = (double)params[5];
  double y;
  y = (1.0/ (pow(x,gamma)*pow(1.0 + pow(x,alpha),(beta-gamma)/alpha)))*x*x*sin(k*x)/(k*x);
  return y;
}

double proj_arnaud_func(double x, void * p) {
  double *params = (double *) p;
  double c500 = (double)params[0];
  double alpha = (double)params[1];
  double beta = (double)params[2];
  double gamma = (double)params[3];
  double R = (double)params[4];
  double yint;
  if (sqrt(x*x-R*R)<0.00001) yint = 0.0;
  else yint = (1.0 / (pow(x,gamma)*pow(1.0 + pow(x,alpha),(beta-gamma)/alpha)))*x / pow(x*x-R*R,0.5);
  return yint;
}

double proj_KS02_func(double x, void * p) {
  double *params = (double *) p;
  double C = (double)params[0];
  double gamma;// = (double)params[1];
  double B;// = (double)params[2];
   double R = (double)params[3];
   double yint, ygas, eta;

  if (sqrt(x*x-R*R)<0.00001) yint = 0.0;
  else{
    gamma = 1.137 + 8.94*pow(10,-2)*log(C/5) - 3.68*pow(10,-3)*(C - 5);
    eta = 2.235 + 0.202*(C - 5)-1.16*pow(10,-3)*pow(C - 5,2);
    B = 3*pow(eta,-1)*(gamma - 1)/gamma*pow((log(1 + C)/C - 1/(1 + C)),-1);
    ygas = pow((1 - B*(1 - log(1 + x)/x)),1/(gamma - 1));
    yint = pow(ygas,gamma)*x / pow(x*x-R*R,0.5);}
  return yint;
}

double yint_func(double x, void * p) {
  double *params = (double *) p;
  float n = (float)params[1];
  float C = (float)params[2];
  float delta_rel = (float)params[0];
  double beta = params[3];
  double R = params[4];
  int pturbrad = (int)params[5];
  float delta_rel_n = params[6];
  float R500_div_ri = params[7];
  gas_model gmod(delta_rel, n, C, 0.0, 0.0, 0.0, pturbrad, delta_rel_n);
  double y;
  y = pow(gmod.theta(x,beta),gmod.n+1.0)*x*x;
  if (pturbrad==2) y = y*(1.0 - delta_rel*pow(x/R500_div_ri, delta_rel_n));
  return y;
}

double mgas500_func(double x, void * p) {
  double *params = (double *) p;
  float n = (float)params[1];
  float C = (float)params[2];
  float delta_rel = (float)params[0];
  //float f_s = (float)params[4];
  double beta = params[3];
  double R = params[4];
  int pturbrad = (int)(params[5]);
  float delta_rel_n = params[6];
  float R500_div_ri = params[7];

  gas_model gmod(0.0, n, C, 0.0, 0.0, 0.0, pturbrad, 0.0);
  double y;
  y = pow(gmod.theta(x,beta),gmod.n)*x*x;
  //if (pturbrad==2) y = y*(1.0 - delta_rel*pow(x/R500_div_ri, delta_rel_n));
  return y;
}

double gasproj_func(double x, void * p) {
  double *params = (double *) p;
  float n = (float)params[1];
  float C = (float)params[2];
  float delta_rel = (float)params[0];
  //float f_s = (float)params[4];
  double beta = params[3];
  double R = params[4];
  int pturbrad = (int)(params[5]);
  float delta_rel_n = params[6];
  float R500_div_ri = params[7];

  gas_model gmod(0.0, n, C, 0.0, 0.0, 0.0, pturbrad, 0.0);
  double y;
  if ((x-R)<0.01) y = 0.0;
  else  y = pow(gmod.theta(x,beta),gmod.n)*x/pow(x*x - R*R,0.5);
  //if (pturbrad==2) y = y*(1.0 - delta_rel*pow(x/R500_div_ri, delta_rel_n));
  return y;
}

// function for solving model goes here

double gasmod_apply_bc(const gsl_vector * v, void *p) {
  double *params = (double *) p;
  float n = (float)params[1];
  float C = (float)params[2];
  float delta_rel = (float)params[0];
  double Aprime = params[4];
  double Bprime = params[5];
  float f_s = (float)params[6];
  int pturbrad = (int)params[7];
  float delta_rel_n= (float) params[8];
  gas_model gmod(delta_rel, n, C, Aprime, Bprime, f_s, pturbrad, delta_rel_n);
  double x0 = gsl_vector_get (v, 0); // beta
  double x1 = gsl_vector_get (v, 1); // Cf
  if (x0<0.01) x0 = 0.01;
  //if (x0>14) x0 = 14;
  if (x1<0.01) x1 = 0.01;
  //if (x1>14) x1 = 14;
  return sqrt(pow(gmod.energy_constraint(x0, x1),2)+pow(gmod.pressure_constraint(x0, x1),2));
}
